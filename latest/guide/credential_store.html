<html>
<head>
<link rel="stylesheet" type="text/css" href="../static/my.css"/>
<link rel="shortcut icon" type="image/png" href="../static/favicon.ico"/>
<title>Credential Store</title>
</head>
<body>
<div id="navigation"><ul class="nav">
<li><a class="nav" href="../index.html">Home</a>
<li><hr/>
<li class="submenu">Getting Started</li>
<ul class="nav">
<li><a class="nav" href="../start/installation.html">Obtaining and Installing Libraries</a>
<li><a class="nav" href="../start/get_started.html">Jumping In</a>
<li><a class="nav" href="../activity_model.html">Understanding the Scope</a>
<li><a class="nav" href="../object_model.html">Understanding the Code Base</a>
<li><a class="nav" href="../available_service_apis.html">Available Specialized Service APIs</a>
</ul>
<li><hr/>
<li class="submenu">Cloud Services</li>
<ul class="nav">
<li><a class="nav" href="../guide/service_requests.html">Making Service Requests</a>
</ul>
<li class="submenu">HTTP</li>
<ul class="nav">
<li><a class="nav" href="../guide/making_http_requests.html">Making HTTP Requests</a>
<li><a class="nav" href="../guide/transport_configure.html">Configuring the Transport Layer</a>
<li><a class="nav" href="../guide/transport_customization.html">Adding Custom HTTP Protocol Implementations</a>
<li><a class="nav" href="../guide/transport_testing.html">Testing and Debugging the Transport Layer</a>
</ul>
<li class="submenu">Data</li>
<ul class="nav">
<li><a class="nav" href="../guide/data_reader.html">Reading and Writing Data</a>
<li><a class="nav" href="../guide/json_data.html">Using JSON Data Objects</a>
</ul>
<li class="submenu">Credentials</li>
<ul class="nav">
<li><a class="nav" href="../guide/oauth2.html">Using OAuth 2.0</a>
<li class="here">Storing Credentials
</ul>
<li class="submenu">C++</li>
<ul class="nav">
<li><a class="nav" href="../guide/types.html">Understanding Foundation Types</a>
</ul>
<li><hr/>
<li><a class="nav" href="../support.html">Getting Help and Reporting Issues</a>
<li><a class="nav" href="../contribute.html">Making Contributions</a>
<li><hr/>
<li><a class="nav" href="../index.html">Other Libraries</a>
</ul></div>
<div id="content">
<table class="layout"><tr>
<td class="proj_name"><img src="../static/logo.png" width="25em" height="25em"/> Google APIs Client Library for C++</td>
<td class="proj_desc"> A C++ library for client applications to access Google APIs.</td>
</tr></table>
<div class="title">Credential Store</div>
<section>
  <p>
    This document discusses the <code>googleapis::client::CredentialStore</code>
    abstraction and implementations provided with the SDK. It also discusses
    how to write and use your own custom <code>CredentialStore</code>.
  </p>
  <aside class='warning'>
    <b>Warning.</b> If stored credentials become compromised then other people
    might obtain access to read or write user data. Storing credentials is
    very convenient but should not be done so haphazardly.
  </aside>
  <aside class='warning'>
    <b>Warning.</b> For extra security you should use bind a <code>Codec</code>
    to the <code>CredentialStore</code> with <code>set_codec</code>.
  </aside>
</section>
<section>
  <h2>Contents</h2>
  <ol>
    <li><a href="#Examples">Typical use case examples</a>
      <ol>
        <a href="#Save">Saving credentials</a>
        <a href="#Restore">Restoring credentials</a>
        <a href="#Remove">Removing credentials</a>
      </ol>
    <li><a href="#ProvidedStores">Provided implementations</a>
      <ol>
        <a href="#FileCredentialStore">FileCredentialStore</a>
      </ol>
    <li><a href="#Codec">Writing a Codec to encrypt a CredentialStore</a>
    <li><a href="#Custom">Writing a custom CredentialStore</a>
  </ol>
</section>
<section id='Examples'>
  <h2>Typical use case examples</h2>
  <p>
    The following snippet is applicable to the examples listed below.
 <pre class='prettyprint'>
// CredentialStore and FileCredentialStore are declared here.
#include "googleapis/client/auth/file_credential_store.h"
#include "googleapis/client/transportu/http_authorization.h"

using googleapis::client::CredentialStore;
using googleapis::client::FileCredentialStoreFactory;</pre>
  </p>
</section>
<section id='BindingOAuth'>
  <h3>Binding a credential store to an OAuth2AuthorizationFlow</h3>
  <p>
    The following binds a CredentialStore to an
    <code>OAuth2AuthorizationFlow</code>. In this case,
    it is a file-based <code>CredentialStore</code>. The actual store
    instance is created from a local factory but ownership of the instance
    is passed into the authorization flow so will live longer than the scope.
  </p>
  <p>
    See the section <a href='#FileCredentialStore'>FileCredentialStore</a>
    below for more explanation about what this sample is doing.
  </p>
  <p>
 <pre class='prettyprint'>
string store_path;
googleapis::util::Status status =
    FileCredentialStoreFactory::GetSystemHomeDirectoryStorePath(&amp;store_path);
if (status.ok()) {
  FileCredentialStoreFactory store_factory(store_path);
  flow-&gt;ResetCredentialStore(
      store_factory.NewCredentialStore("CalendarSample", &amp;status));
}
if (!status.ok()) {
  LOG(ERROR)
      &lt;&lt; "Failed creating credential store: " &lt;&lt; status.error_message();
}</pre>
  </p>
</section>
<section id='Save'>
  <h3>Saving a credential</h3>
  <p>
    Normally the <code>OAuth2AuthorizationFlow</code> will automatically
    store credentials into the credential store bound to it so there is no
    need to call the CredentialStore directly. You can still explicitly store
    a credential yourself if you need to.
  </p>
  <p>
    The credential store interface associates an external
    <code>user_name</code> key with the credential. This is a key that your
    application picks to associate with the desired user that this credential
    is for. When using OAuth 2.0 credentials, this could be the user_id()
    attribute of the OAuth2Credential.
  </p>
  <p>
    The <code>Store</code> method takes the user_id and credential instance,
    stores the serialized credential for later retrieval.
 <pre class='prettyprint'>
status = credential_store-&gt;Store(user_id, credential);
if (!status.ok()) {
  LOG(ERROR) &lt;&lt; "Failed storing credentials: " &lt;&lt; status.error_message();
}</pre>
  </p>
</section>
<section id='Restore'>
  <h3>Restoring a credential</h3>
  <p>
    Normally the <code>OAuth2AuthorizationFlow</code> will automatically
    attempt to load credentials from the <code>CredentialStore</code> bound
    to it so there is no need to call the CredentialStore yourself.
    You can still explicitly store a credential yourself if you need to.
  </p>
  <p>
    Credentials are loaded by giving the desired key to the
    <code>InitCredential</code> method on the store. The key should be the
    same as the one used for the <code>Store</code> method. This will
    re-initialize the credential with the data from the store with any.
    On failure, the credential will be cleared of any prior data.
 <pre class='prettyprint'>
status = credential_store-&gt;InitCredential(user_id, &amp;credential);
if (!status.ok()) {
  // usually this means the credentials are not known or available,
  // such as a first-time user.
}</pre>
</section>
<section id='Removing'>
  <h3>Removing a credential</h3>
  <p>
    You may explicitly remove a credential from a store by calling the
    <code>Delete</code> method with the key used to store the credential.
    This does not revoke the credentials, it just removes them from the store.
  </p>
  <p>
    The following snippet deletes a credential from the store but does not
    actually revoke the credential. To revoke an OAuth 2.0 credential,
    call <code>OAuth2AuthorizationFlow::NewRevokeRefreshTokenRequest</code>.
  </p>
 <pre class='prettyprint'>
status = credential_store-&gt;Delete(user_id);</pre>
</section>
<section id='ProvidedStores'>
  <h2>Provided implementations</h2>
</section>
<section id='FileCredentialStore'>
  <h3>FileCredentialStore</h3>
  <p>
    The <code>FileCredentialStore</code> is uses the file system to store
    credentials. It takes some precautions to protecting the data, such as
    using user read/write-only files however a filesystem is not as secure
    as other mechanisms or platform-specific key stores. If the machine and
    disk is compromised then the credentials can become compromised to
    gain access to personal data in cloud services.
  </p>
  <aside class='warning'>
    <b>Warning.</b> For extra security you should use bind a <code>Codec</code>
    to the <code>CredentialStore</code> with <code>set_codec</code>.
  </aside>
  <aside class='note'>
    <b>Note.</b> The current release does not yet provide a concrete
    implementation of the <code>Codec</code> interface so you will need
    to write your own as described elsewhere in this document.
  </aside>
  <p>
    For programming convenience the
    <code>CredentialStore</code> interface is organized as a
    map of <em>client applications</em> to <em>users</em> then users to
    <em>credentials</em>. However for user maintenance convenience the
    file credential store internally organizes itself as a map of
    <em>users</em> to <em>client applications</em>, then client applications
    to credentials for that user.
  </p>
  <p>
    Consider a scenario where a user (person) uses multiple
    client applications (Application1, Application2, Application3).
    In addition, they have multiple cloud identities so may use different
    Google Accounts for different applications or the same account for
    multiple applications. Each of these applications might be using
    a <code>FileCredentialStore</code> using the same filesystem in their
    local computer's filesystem because their Google Account cloud identity
    is different from their native operating system's login id. The physical
    credential store as stored on disk might look as follows.
  </p>
  <ul>
    <li><em>UserHomeDirectory</em><code>.googleapis/credentials/</code>
      <ul>
        <li><em>user_identityA</em>/
          <ul>
            <li><em>Application1</em>
            <li><em>Application2</em>
          </ul>
        <li><em>user_identityB</em>/
          <ul>
            <li><em>Application1</em>
            <li><em>Application3</em>
          </ul>
      </ul>
  </ul>
  <p>
    The actual <code>FileCredentialStore</code> class is not
    public. It only exposes the abstract <code>CredentialStore</code> interface.
    In order to instantiate one, you must use a
    <code>FileCredentialStoreFactory</code> as illustrated in the snippet
    below.
 <pre class='prettyprint'>
string store_path;
googleapis::util::Status status =
    FileCredentialStoreFactory::GetSystemHomeDirectoryStorePath(&amp;store_path);
if (status.ok()) {
  FileCredentialStoreFactory store_factory(store_path);
  flow-&gt;ResetCredentialStore(
      store_factory.NewCredentialStore("CalendarSample", &amp;status));
}
if (!status.ok()) {
  LOG(ERROR)
      &lt;&lt; "Failed creating credential store: " &lt;&lt; status.error_message();
}</pre>
  </p>
  <p>
    The <code>FileCredentialStoreFactory</code> has a <em>root_path</em>
    attribute specifying the top-level directory where it will store the
    credentials.
    The <code>FileCredentialStore::SystemHomeDirectoryStorePath</code> returns
    a subdirectory off the user <code>$HOME</code> directory,
    <code>.googleapis/credentials</code>.
  </p>
</section>
<section id='Codec'>
  <h2>Writing a codec to encrypt a CredentialStore</h2>
  <p>
    Future releases will provide a standard <code>Codec</code> implementation
    for encrypting data in credential stores. However at present there is
    no such implementation so you will need to write your own.
  </p>
<pre class='prettyprint'>
#include "googleapis/client/util/file_utils.h"
#include "googleapis/client/util/status.h"
using googleapis::client::Codec;
using googleapis::util::Status;

class MyEncryptionCodec : public Codec {
public:
  virtual Status Encode(const StringPiece& decoded, string* encoded) {
     *encoded = MyEncryptionAlgorithm(decoded);
     return googleapis::util::StatusOk();
  }
  virtual Status Decode(const StringPiece& encoded, string* decoded) {
     *decoded = MyDecryptionAlgorithm(encoded);
     return googleapis::util::StatusOk();
  }
};
...
credential_store->set_codec(new MyEncryptionCodec);
</pre>
</section>
<section id='Custom'>
  <h2>Writing a custom CredentialStore</h2>
  <p>
    In future releases the SDK will probably support native credential stores.
    In the meantime, or if you have some proprietary mechanism for secure
    storage, you can write your own specialized <code>CredentialStore</code>
    by implementing the minimal pure virtual methods in the interface. To
    get the content of the credential, use the
    <code>DecodeToEncodingReader</code> and <code>EncodeToDecodingReader</code>
    methods. These will handle the transformations (such as encryption) that
    the where externally configured on the store.
  </p>
 <pre class='prettyprint'>
using googleapis::client::AuthorizationCredential;
using googleapis::client::DataReader;
class MyCredentialStore : public CredentialStore {
 public:
  MyCredentialStore() {}
  virtual ~MyCredentialStore() {}

  virtual googleapis::util::Status Store(
      const StringPiece&amp; user, const AuthorizationCredential&amp; credential) {
    googleapis::util::Status status;
    scoped_ptr&lt;DataReader&gt;encoder(
        DecodedToEncodingReader(credential.MakeDataReader(), &amp;status));
    if (!status.ok()) return status;

    string serialized = encoder-&gt;RemainderToString();
    return StoreStringInMyMechanism(user, serialized);
  }

  virtual googleapis::util::Status InitCredential(
      const StringPiece&amp; user, AuthorizationCredential* credential) {
    string data;
    googleapis::util::Status status = LoadStringFromMyMechanism(user, &amp;data);
    if (!status.ok()) return status;

    scoped_ptr&lt;DataReader&gt; decoder(
        EncodedToDecodingReader(
            googleapis::client::NewUnmanagedInMemoryDataReader(data),
            &amp;status));
    if (!status.ok()) return status;

    return credential-&gt;Load(decoder.get());
  }

  virtual googleapis::util::Status Delete(const StringPiece&amp; user) {
    return DeleteStringFromMyMechanism(user);
  }

 private:
  googleapis::util::Status StoreStringInMyMechanism(
      const StringPiece&amp; key, const string&amp; str) {
    // This is where you store the key/str value pair into your mechanism.
    // On failure you'd return an error status with explanation.
    return googleapis::util::StatusOk();
  }
  googleapis::util::Status LoadStringFromMyMechanism(
      const StringPiece&amp; key, string* str) {
    // This is where you load the str value for the key from your mechanism.
    // On failure you'd return an error status with explanation.
    *str = "";
    return googleapis::util::StatusOk();
  }
  googleapis::util::Status DeleteStringFromMyMechanism(
      const StringPiece&amp; key) {
    // This is where you delete the key from your mechanism.
    // On failure you'd return an error status with explanation.
    return googleapis::util::StatusOk();
  }
};</pre>
</section>
</div>

<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol)
             ? "https://ssl." : "http://www.");

document.write(unescape("%3Cscript src='" + gaJsHost
   + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>

<script type="text/javascript">
try{
var pageTracker = _gat._getTracker("UA-18058-15");
pageTracker._trackPageview();
} catch(err) {}</script>
</body>
</html>