<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Google APIs Client Library for C++: Data Layer - Raw Data Management</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Google APIs Client Library for C++
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="dynsections.js"></script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('group__DataLayerRaw.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Data Layer - Raw Data Management</div>  </div>
</div><!--header-->
<div class="contents">

<p>The raw data management module is responsible for access to and manipulation of raw data.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogleapis_1_1client_1_1DataReader.html">DataReader</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for reading from an asynchronous binary data stream.  <a href="classgoogleapis_1_1client_1_1DataReader.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgoogleapis_1_1client_1_1DataWriter.html">DataWriter</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for writing into synchronous binary data stream.  <a href="classgoogleapis_1_1client_1_1DataWriter.html#details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DataReader *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DataLayerRaw.html#gaaa0950354abff6273a1831d57cc10deb">NewManagedInvalidDataReader</a> (util::Status status, Closure *deleter)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a data reader that is always in an error state.  <a href="#gaaa0950354abff6273a1831d57cc10deb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DataReader *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DataLayerRaw.html#gaf9da7912a6fdf70a818a008314b58021">NewUnmanagedInvalidDataReader</a> (util::Status status)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an unmanaged invalid data reader.  <a href="#gaf9da7912a6fdf70a818a008314b58021"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DataReader *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DataLayerRaw.html#gab17dc91af13bfa23acee8a2224d87ff4">NewManagedInMemoryDataReader</a> (const StringPiece &amp;data, Closure *deleter)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads from a contiguous byte array.  <a href="#gab17dc91af13bfa23acee8a2224d87ff4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DataReader *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DataLayerRaw.html#ga8edb9c6d11fa6b4fdd95dd6b0fef22d9">NewUnmanagedInMemoryDataReader</a> (const StringPiece &amp;data)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an unmanaged InMenoryDataReaderThis is shorthand for NewManagedInMemoryDataReader(data, NULL)  <a href="#ga8edb9c6d11fa6b4fdd95dd6b0fef22d9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DataReader *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DataLayerRaw.html#ga1a20838520845a186f77d4de3c171b3f">NewManagedInMemoryDataReader</a> (string *data)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a managed reader that consumes a dynanic input string.  <a href="#ga1a20838520845a186f77d4de3c171b3f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DataReader *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DataLayerRaw.html#gad25ee6f6c3d0ca9cc9c1334385bfb7c1">NewManagedInMemoryDataReader</a> (const string &amp;data)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a managed InMemoryDataReader from an existing string.  <a href="#gad25ee6f6c3d0ca9cc9c1334385bfb7c1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DataReader *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DataLayerRaw.html#gae0686a4c5b5cef15475903a6d14b094c">NewManagedBufferedDataReader</a> (DataReader *reader, int64 buffer_bytes)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an InMemoryDataReader that returns the content from another data reader.  <a href="#gae0686a4c5b5cef15475903a6d14b094c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DataReader *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DataLayerRaw.html#ga1b09b3e58599bfe2a5f9cc23bdae77cd">NewUnmanagedBufferedDataReader</a> (DataReader *reader, int64 buffer_bytes)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to NewUManagedBufferdDataReader but the caller retains ownership of the original reader.  <a href="#ga1b09b3e58599bfe2a5f9cc23bdae77cd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DataReader *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DataLayerRaw.html#gae5a58e96eebfb60a34a63071ec3ea54f">NewManagedBufferedDataReader</a> (DataReader *reader, int64 buffer_bytes, Closure *deleter)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A general form of a managed BufferedDataReader.  <a href="#gae5a58e96eebfb60a34a63071ec3ea54f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DataReader *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DataLayerRaw.html#ga59bbb650f22862bd45ae281d9bf1c074">NewUnmanagedCompositeDataReader</a> (const vector&lt; DataReader * &gt; &amp;readers)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an unmanaged composite <a class="el" href="classgoogleapis_1_1client_1_1DataReader.html" title="Interface for reading from an asynchronous binary data stream.">DataReader</a> that reads directly from one or more other data readers.  <a href="#ga59bbb650f22862bd45ae281d9bf1c074"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DataReader *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DataLayerRaw.html#ga4677b5fe94b8265e07f0eace9f8cb836">NewManagedCompositeDataReader</a> (const vector&lt; DataReader * &gt; &amp;readers, Closure *deleter)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a managed composite <a class="el" href="classgoogleapis_1_1client_1_1DataReader.html" title="Interface for reading from an asynchronous binary data stream.">DataReader</a> that reads directly from one or more other data readers.  <a href="#ga4677b5fe94b8265e07f0eace9f8cb836"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Closure *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DataLayerRaw.html#ga8fac15adcd5d3406bb57bdc128274719">NewCompositeReaderListAndContainerDeleter</a> (vector&lt; DataReader * &gt; *readers)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a managed closure that deletes an entire vector of readers when run.  <a href="#ga8fac15adcd5d3406bb57bdc128274719"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DataReader *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DataLayerRaw.html#ga2172edaca43d7413a9b54ba9e3001f53">NewManagedFileDataReader</a> (const StringPiece &amp;path, Closure *deleter)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a managed <a class="el" href="classgoogleapis_1_1client_1_1DataReader.html" title="Interface for reading from an asynchronous binary data stream.">DataReader</a> that reads its byte stream from a file on disk.  <a href="#ga2172edaca43d7413a9b54ba9e3001f53"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DataReader *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DataLayerRaw.html#ga2278ef714f833c4f83b7d32d1e55b903">NewUnmanagedFileDataReader</a> (const StringPiece &amp;path)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an unmanaged <a class="el" href="classgoogleapis_1_1client_1_1DataReader.html" title="Interface for reading from an asynchronous binary data stream.">DataReader</a> that reads its byte stream from a file on disk.  <a href="#ga2278ef714f833c4f83b7d32d1e55b903"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DataReader *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DataLayerRaw.html#ga70150a057f07ff60dbb0600b000010e0">NewManagedIstreamDataReader</a> (std::istream *stream, Closure *deleter)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a managed reader that reads its byte stream from a generic C++ std::istream of unknown length.  <a href="#ga70150a057f07ff60dbb0600b000010e0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DataReader *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DataLayerRaw.html#gab70fc0ec6e73bfada94cab7985452734">NewManagedIstreamDataReaderWithLength</a> (std::istream *stream, int64 length, Closure *deleter)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a managed reader that reads its byte stream from a generic C++ std::istream of unknown length.  <a href="#gab70fc0ec6e73bfada94cab7985452734"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DataReader *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DataLayerRaw.html#gafd8bc6aea5793ea1b5bbd4a971ba3217">NewUnmanagedIstreamDataReader</a> (std::istream *stream)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an unmanaged reader that reads its byte stream from a generic C++ std::istream of unknown length.  <a href="#gafd8bc6aea5793ea1b5bbd4a971ba3217"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DataReader *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DataLayerRaw.html#ga51f3f98a55aa9d27548e410362e891e3">NewUnmanagedIstreamDataReaderWithLength</a> (std::istream *stream, int64 length)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an unmanaged reader that reads its byte stream from a generic C++ std::istream of a known length.  <a href="#ga51f3f98a55aa9d27548e410362e891e3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DataWriter *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DataLayerRaw.html#ga9174620e1dde19e77b70fb008faf96a1">NewFileDataWriter</a> (const StringPiece &amp;path)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a data writer that rewrites the file at the given path.  <a href="#ga9174620e1dde19e77b70fb008faf96a1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DataWriter *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DataLayerRaw.html#ga594148af303ec9aa427cb8ac31d7fb39">NewFileDataWriter</a> (const StringPiece &amp;path, const FileOpenOptions &amp;options)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a data writer that rewrites the file at the given path with control over how the file is created.  <a href="#ga594148af303ec9aa427cb8ac31d7fb39"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DataWriter *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DataLayerRaw.html#gaf6f08b47021a4198f282c09ee1411a02">NewStringDataWriter</a> (string *s)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a data writer that rewrites the given string.  <a href="#gaf6f08b47021a4198f282c09ee1411a02"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DataWriter *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DataLayerRaw.html#ga678c8fa7ee1d08e179664272a4d874d5">NewStringDataWriter</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an in-memory data writer that encapsulates the memory it uses.  <a href="#ga678c8fa7ee1d08e179664272a4d874d5"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<p>The raw data management module is responsible for access to and manipulation of raw data. </p>
<p>It provides abstractions and mechanisms for supplying data for messaging payloads, and for getting the data out of those payloads. As a rule of thumb it provides data support without being tied to the HTTP Transport Layer or involving any inter-process messaging. The concepts it defines are used throughout the Google APIs Client Libraries for C++ to help facilitate passing data through the various components and subsystems. </p>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga8fac15adcd5d3406bb57bdc128274719"></a><!-- doxytag: member="googleapis::client::NewCompositeReaderListAndContainerDeleter" ref="ga8fac15adcd5d3406bb57bdc128274719" args="(vector&lt; DataReader * &gt; *readers)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Closure* <a class="el" href="group__DataLayerRaw.html#ga8fac15adcd5d3406bb57bdc128274719">googleapis::client::NewCompositeReaderListAndContainerDeleter</a> </td>
          <td>(</td>
          <td class="paramtype">vector&lt; DataReader * &gt; *&#160;</td>
          <td class="paramname"><em>readers</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a managed closure that deletes an entire vector of readers when run. </p>
<p>This is a convienence function for creating a closure to pass to NewManagedCompositeDataReader.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">readers</td><td>Takes ownership of the vector and its contents are passed so the vector should hae been allocated with the new operator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga9174620e1dde19e77b70fb008faf96a1"></a><!-- doxytag: member="googleapis::client::NewFileDataWriter" ref="ga9174620e1dde19e77b70fb008faf96a1" args="(const StringPiece &amp;path)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DataWriter* <a class="el" href="group__DataLayerRaw.html#ga9174620e1dde19e77b70fb008faf96a1">googleapis::client::NewFileDataWriter</a> </td>
          <td>(</td>
          <td class="paramtype">const StringPiece &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a data writer that rewrites the file at the given path. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>The caller will own the file at the given path. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga594148af303ec9aa427cb8ac31d7fb39"></a><!-- doxytag: member="googleapis::client::NewFileDataWriter" ref="ga594148af303ec9aa427cb8ac31d7fb39" args="(const StringPiece &amp;path, const FileOpenOptions &amp;options)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DataWriter* <a class="el" href="group__DataLayerRaw.html#ga9174620e1dde19e77b70fb008faf96a1">googleapis::client::NewFileDataWriter</a> </td>
          <td>(</td>
          <td class="paramtype">const StringPiece &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FileOpenOptions &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a data writer that rewrites the file at the given path with control over how the file is created. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>The caller will own the file at the given path. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>The options can be used to override the permissions to given the created file. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae0686a4c5b5cef15475903a6d14b094c"></a><!-- doxytag: member="googleapis::client::NewManagedBufferedDataReader" ref="gae0686a4c5b5cef15475903a6d14b094c" args="(DataReader *reader, int64 buffer_bytes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DataReader* <a class="el" href="group__DataLayerRaw.html#gae0686a4c5b5cef15475903a6d14b094c">googleapis::client::NewManagedBufferedDataReader</a> </td>
          <td>(</td>
          <td class="paramtype">DataReader *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64&#160;</td>
          <td class="paramname"><em>buffer_bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns an InMemoryDataReader that returns the content from another data reader. </p>
<p>This reader is only intended to make unreliable readers reliable when you need to reset them. It is high overhead since you are creating an in-memory copy of the data, which defeats the whole point of having a reader and will cost twice the storage.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">reader</td><td>Ownership of the wrapped reader will be passed the new instance to manage. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer_bytes</td><td>The total number of bytes to expect, or -1 if unknown. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae5a58e96eebfb60a34a63071ec3ea54f"></a><!-- doxytag: member="googleapis::client::NewManagedBufferedDataReader" ref="gae5a58e96eebfb60a34a63071ec3ea54f" args="(DataReader *reader, int64 buffer_bytes, Closure *deleter)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DataReader* <a class="el" href="group__DataLayerRaw.html#gae0686a4c5b5cef15475903a6d14b094c">googleapis::client::NewManagedBufferedDataReader</a> </td>
          <td>(</td>
          <td class="paramtype">DataReader *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64&#160;</td>
          <td class="paramname"><em>buffer_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Closure *&#160;</td>
          <td class="paramname"><em>deleter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A general form of a managed BufferedDataReader. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">reader</td><td>The caller maintains ownership of this reader, however the caller may have passed ownership to the deleter. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer_bytes</td><td>The number of bytes to expect in the reader, or -1 if not known. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">deleter</td><td>The management closure to call when this instance is destroyed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4677b5fe94b8265e07f0eace9f8cb836"></a><!-- doxytag: member="googleapis::client::NewManagedCompositeDataReader" ref="ga4677b5fe94b8265e07f0eace9f8cb836" args="(const vector&lt; DataReader * &gt; &amp;readers, Closure *deleter)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DataReader* <a class="el" href="group__DataLayerRaw.html#ga4677b5fe94b8265e07f0eace9f8cb836">googleapis::client::NewManagedCompositeDataReader</a> </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; DataReader * &gt; &amp;&#160;</td>
          <td class="paramname"><em>readers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Closure *&#160;</td>
          <td class="paramname"><em>deleter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a managed composite <a class="el" href="classgoogleapis_1_1client_1_1DataReader.html" title="Interface for reading from an asynchronous binary data stream.">DataReader</a> that reads directly from one or more other data readers. </p>
<p>The composite readers are not buffered at all by this reader so little additional overhead is added. The component readers within this may come from different types of sources or might just have different fragments of memory.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">readers</td><td>The list of readers taht define the byte sequence returned by this reader. The caller retains ownership of each of these readers though may pass their ownership to the deleter. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">deleter</td><td>The management closure to be called when the composite reader is destroyed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga2172edaca43d7413a9b54ba9e3001f53"></a><!-- doxytag: member="googleapis::client::NewManagedFileDataReader" ref="ga2172edaca43d7413a9b54ba9e3001f53" args="(const StringPiece &amp;path, Closure *deleter)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DataReader* <a class="el" href="group__DataLayerRaw.html#ga2172edaca43d7413a9b54ba9e3001f53">googleapis::client::NewManagedFileDataReader</a> </td>
          <td>(</td>
          <td class="paramtype">const StringPiece &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Closure *&#160;</td>
          <td class="paramname"><em>deleter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a managed <a class="el" href="classgoogleapis_1_1client_1_1DataReader.html" title="Interface for reading from an asynchronous binary data stream.">DataReader</a> that reads its byte stream from a file on disk. </p>
<p>If the path does not exist, or cannot be read for some other reason then this will return a reader in the error state. Check its status() to get more details on the error.</p>
<p>The caller should ensure the file remains valid and unchanged over the lifetime of the reader. Changing the file contents will corrupt the reader.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>The path to the file to read from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">deleter</td><td>If non-NULL this closure will be called when the reader is destroyed. The reader itself will no longer be valid when the closure is called. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab17dc91af13bfa23acee8a2224d87ff4"></a><!-- doxytag: member="googleapis::client::NewManagedInMemoryDataReader" ref="gab17dc91af13bfa23acee8a2224d87ff4" args="(const StringPiece &amp;data, Closure *deleter)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DataReader* <a class="el" href="group__DataLayerRaw.html#gab17dc91af13bfa23acee8a2224d87ff4">googleapis::client::NewManagedInMemoryDataReader</a> </td>
          <td>(</td>
          <td class="paramtype">const StringPiece &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Closure *&#160;</td>
          <td class="paramname"><em>deleter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reads from a contiguous byte array. </p>
<p>Managed InMemoryDataReader instances are very low overhead if the memory already exists. However, the owner must ensure that the referenced data remains valid and unchanged over the lifetime of the reader. Modifying the data will corrupt the reader.</p>
<p>Unmanaged instances can pass memory ownership into the instance itself and have the instance encapsulate it by being the only remaining direct reference. This reduces the chance for the data to get corrupted and guarantees that the data will remain vaid for as long, and only as long, as the reader remains.</p>
<p>For brevity only StringPiece variations are provided. If you have an ordinary char*, you can turn it into a StringPiece by passing StringPiece(ptr, len) presuming that you know the length. If you do not know the length then you cannot use the InMemoryDataReader anyway.</p>
<p>If your char* is part of a larger object which you only need to support the reader, you can have the reader manage it by passing a DeletePointerClosure as the reader's managing closure.</p>
<pre>
   char* data = obj-&gt;data()
   int64 len = obj-&gt;data_len()
   NewManagedInMemoryDataReader(StringPiece(data, len),
                                DeletePointerClosure(obj))
 </pre><dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>The data used by the reader must remain valid and unchanged over the lifetime of the readaer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">deleter</td><td>If non-NULL then this will be a managed reader calling the deletre when this object is destroyed. See the base <a class="el" href="classgoogleapis_1_1client_1_1DataReader.html" title="Interface for reading from an asynchronous binary data stream.">DataReader</a> class for more information about managed readers. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga1a20838520845a186f77d4de3c171b3f"></a><!-- doxytag: member="googleapis::client::NewManagedInMemoryDataReader" ref="ga1a20838520845a186f77d4de3c171b3f" args="(string *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DataReader* <a class="el" href="group__DataLayerRaw.html#gab17dc91af13bfa23acee8a2224d87ff4">googleapis::client::NewManagedInMemoryDataReader</a> </td>
          <td>(</td>
          <td class="paramtype">string *&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a managed reader that consumes a dynanic input string. </p>
<p>This is a convienence function to create a managed reader from a string pinter.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Takes ownership of the string </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__DataLayerRaw.html#gab17dc91af13bfa23acee8a2224d87ff4" title="Reads from a contiguous byte array.">NewManagedInMemoryDataReader</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gad25ee6f6c3d0ca9cc9c1334385bfb7c1"></a><!-- doxytag: member="googleapis::client::NewManagedInMemoryDataReader" ref="gad25ee6f6c3d0ca9cc9c1334385bfb7c1" args="(const string &amp;data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DataReader* <a class="el" href="group__DataLayerRaw.html#gab17dc91af13bfa23acee8a2224d87ff4">googleapis::client::NewManagedInMemoryDataReader</a> </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a managed InMemoryDataReader from an existing string. </p>
<p>This function will create a copy of the string then manage the copy.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__DataLayerRaw.html#gab17dc91af13bfa23acee8a2224d87ff4" title="Reads from a contiguous byte array.">NewManagedInMemoryDataReader</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaaa0950354abff6273a1831d57cc10deb"></a><!-- doxytag: member="googleapis::client::NewManagedInvalidDataReader" ref="gaaa0950354abff6273a1831d57cc10deb" args="(util::Status status, Closure *deleter)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DataReader* <a class="el" href="group__DataLayerRaw.html#gaaa0950354abff6273a1831d57cc10deb">googleapis::client::NewManagedInvalidDataReader</a> </td>
          <td>(</td>
          <td class="paramtype">util::Status&#160;</td>
          <td class="paramname"><em>status</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Closure *&#160;</td>
          <td class="paramname"><em>deleter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a data reader that is always in an error state. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">status</td><td>The permanent status() to give the reader, expaining why any access to it will fail. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">deleter</td><td>If non-NULL this reader will be a "managed" reader and run teh deleter in its destructor.</td></tr>
  </table>
  </dd>
</dl>
<p>This reader is meant to be returned by factory methdos that fail. It is a placeholder value so that DataReaders are never NULL. </p>

</div>
</div>
<a class="anchor" id="ga70150a057f07ff60dbb0600b000010e0"></a><!-- doxytag: member="googleapis::client::NewManagedIstreamDataReader" ref="ga70150a057f07ff60dbb0600b000010e0" args="(std::istream *stream, Closure *deleter)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DataReader* <a class="el" href="group__DataLayerRaw.html#ga70150a057f07ff60dbb0600b000010e0">googleapis::client::NewManagedIstreamDataReader</a> </td>
          <td>(</td>
          <td class="paramtype">std::istream *&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Closure *&#160;</td>
          <td class="paramname"><em>deleter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a managed reader that reads its byte stream from a generic C++ std::istream of unknown length. </p>
<p>If you know how many bytes are in the stream then you should use NewManagedIstreamDataReaderWithLength</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td>The caller retains ownership of the stream to read from, though the caller may pass ownership to the deleter. The caller must insure it remains valid over the lifetime of the reader, and should not read from it outside the returned reader. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">deleter</td><td>The managing closure is called when the reaer is destroyed. The reader will not be valid when the deleter is called.</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd>NewDeleterClosure </dd>
<dd>
<a class="el" href="group__DataLayerRaw.html#ga2172edaca43d7413a9b54ba9e3001f53" title="Creates a managed DataReader that reads its byte stream from a file on disk.">NewManagedFileDataReader</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gab70fc0ec6e73bfada94cab7985452734"></a><!-- doxytag: member="googleapis::client::NewManagedIstreamDataReaderWithLength" ref="gab70fc0ec6e73bfada94cab7985452734" args="(std::istream *stream, int64 length, Closure *deleter)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DataReader* <a class="el" href="group__DataLayerRaw.html#gab70fc0ec6e73bfada94cab7985452734">googleapis::client::NewManagedIstreamDataReaderWithLength</a> </td>
          <td>(</td>
          <td class="paramtype">std::istream *&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Closure *&#160;</td>
          <td class="paramname"><em>deleter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a managed reader that reads its byte stream from a generic C++ std::istream of unknown length. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td>The caller retains ownership of the stream to read from, though the caller may pass ownership to the deleter. The caller must insure it remains valid over the lifetime of the reader, and should not read from it outside the returned reader. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>The length if known, or -1 can be used if unknown. A length of 0 indicates and empty stream. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">deleter</td><td>The managing closure is called when the reaer is destroyed. The reader will not be valid when the deleter is called.</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd>NewDeleterClosure </dd>
<dd>
NewMmanagedFileDataReader </dd></dl>

</div>
</div>
<a class="anchor" id="gaf6f08b47021a4198f282c09ee1411a02"></a><!-- doxytag: member="googleapis::client::NewStringDataWriter" ref="gaf6f08b47021a4198f282c09ee1411a02" args="(string *s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DataWriter* <a class="el" href="group__DataLayerRaw.html#gaf6f08b47021a4198f282c09ee1411a02">googleapis::client::NewStringDataWriter</a> </td>
          <td>(</td>
          <td class="paramtype">string *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a data writer that rewrites the given string. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>A pointer to a string owned by the caller. This string will remain valid after the writer is destroyed. Use <code>s-&gt;data()</code> rather than <code>s-&gt;c_str()</code> if you need to access the raw bytes in the string since the writer may be given binary data. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga678c8fa7ee1d08e179664272a4d874d5"></a><!-- doxytag: member="googleapis::client::NewStringDataWriter" ref="ga678c8fa7ee1d08e179664272a4d874d5" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DataWriter* <a class="el" href="group__DataLayerRaw.html#gaf6f08b47021a4198f282c09ee1411a02">googleapis::client::NewStringDataWriter</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates an in-memory data writer that encapsulates the memory it uses. </p>

</div>
</div>
<a class="anchor" id="ga1b09b3e58599bfe2a5f9cc23bdae77cd"></a><!-- doxytag: member="googleapis::client::NewUnmanagedBufferedDataReader" ref="ga1b09b3e58599bfe2a5f9cc23bdae77cd" args="(DataReader *reader, int64 buffer_bytes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DataReader* <a class="el" href="group__DataLayerRaw.html#ga1b09b3e58599bfe2a5f9cc23bdae77cd">googleapis::client::NewUnmanagedBufferedDataReader</a> </td>
          <td>(</td>
          <td class="paramtype">DataReader *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64&#160;</td>
          <td class="paramname"><em>buffer_bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Similar to NewUManagedBufferdDataReader but the caller retains ownership of the original reader. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">reader</td><td>The caller keeps ownership of the reader being wrapped. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer_bytes</td><td>The total number of bytes to expect, or -1 if unknown.</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__DataLayerRaw.html#gae0686a4c5b5cef15475903a6d14b094c" title="Returns an InMemoryDataReader that returns the content from another data reader.">NewManagedBufferedDataReader</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga59bbb650f22862bd45ae281d9bf1c074"></a><!-- doxytag: member="googleapis::client::NewUnmanagedCompositeDataReader" ref="ga59bbb650f22862bd45ae281d9bf1c074" args="(const vector&lt; DataReader * &gt; &amp;readers)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DataReader* <a class="el" href="group__DataLayerRaw.html#ga59bbb650f22862bd45ae281d9bf1c074">googleapis::client::NewUnmanagedCompositeDataReader</a> </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; DataReader * &gt; &amp;&#160;</td>
          <td class="paramname"><em>readers</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns an unmanaged composite <a class="el" href="classgoogleapis_1_1client_1_1DataReader.html" title="Interface for reading from an asynchronous binary data stream.">DataReader</a> that reads directly from one or more other data readers. </p>
<p>The composite readers are not buffered at all by this reader so little additional overhead is added. The component readers within this may come from different types of sources or might just have different fragments of memory.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">readers</td><td>The list of readers taht define the byte sequence returned by this reader. The caller retains ownership of each of these and must guarantee they are kept valid and otherwise unused over the lifetime of this instance. if data is read from any of these outside the composite reader then the compsite reader will be corrupted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga2278ef714f833c4f83b7d32d1e55b903"></a><!-- doxytag: member="googleapis::client::NewUnmanagedFileDataReader" ref="ga2278ef714f833c4f83b7d32d1e55b903" args="(const StringPiece &amp;path)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DataReader* <a class="el" href="group__DataLayerRaw.html#ga2278ef714f833c4f83b7d32d1e55b903">googleapis::client::NewUnmanagedFileDataReader</a> </td>
          <td>(</td>
          <td class="paramtype">const StringPiece &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates an unmanaged <a class="el" href="classgoogleapis_1_1client_1_1DataReader.html" title="Interface for reading from an asynchronous binary data stream.">DataReader</a> that reads its byte stream from a file on disk. </p>
<p>If the path does not exist, or cannot be read for some other reason then this will return a reader in the error state. Check its status() to get more details on the error.</p>
<p>The caller should ensure the file remains valid and unchanged over the lifetime of the reader. Changing the file contents will corrupt the reader.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>The path to the file to read from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga8edb9c6d11fa6b4fdd95dd6b0fef22d9"></a><!-- doxytag: member="googleapis::client::NewUnmanagedInMemoryDataReader" ref="ga8edb9c6d11fa6b4fdd95dd6b0fef22d9" args="(const StringPiece &amp;data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DataReader* <a class="el" href="group__DataLayerRaw.html#ga8edb9c6d11fa6b4fdd95dd6b0fef22d9">googleapis::client::NewUnmanagedInMemoryDataReader</a> </td>
          <td>(</td>
          <td class="paramtype">const StringPiece &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates an unmanaged InMenoryDataReaderThis is shorthand for NewManagedInMemoryDataReader(data, NULL) </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__DataLayerRaw.html#gab17dc91af13bfa23acee8a2224d87ff4" title="Reads from a contiguous byte array.">NewManagedInMemoryDataReader</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaf9da7912a6fdf70a818a008314b58021"></a><!-- doxytag: member="googleapis::client::NewUnmanagedInvalidDataReader" ref="gaf9da7912a6fdf70a818a008314b58021" args="(util::Status status)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DataReader* <a class="el" href="group__DataLayerRaw.html#gaf9da7912a6fdf70a818a008314b58021">googleapis::client::NewUnmanagedInvalidDataReader</a> </td>
          <td>(</td>
          <td class="paramtype">util::Status&#160;</td>
          <td class="paramname"><em>status</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns an unmanaged invalid data reader. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">status</td><td>The permanent status() to give the reader.</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__DataLayerRaw.html#gaaa0950354abff6273a1831d57cc10deb" title="Returns a data reader that is always in an error state.">NewManagedInvalidDataReader</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gafd8bc6aea5793ea1b5bbd4a971ba3217"></a><!-- doxytag: member="googleapis::client::NewUnmanagedIstreamDataReader" ref="gafd8bc6aea5793ea1b5bbd4a971ba3217" args="(std::istream *stream)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DataReader* <a class="el" href="group__DataLayerRaw.html#gafd8bc6aea5793ea1b5bbd4a971ba3217">googleapis::client::NewUnmanagedIstreamDataReader</a> </td>
          <td>(</td>
          <td class="paramtype">std::istream *&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates an unmanaged reader that reads its byte stream from a generic C++ std::istream of unknown length. </p>
<p>This is similar to NewManagedIstreamDataReader, but with a NULL deleter.</p>
<dl class="see"><dt><b>See also:</b></dt><dd>NewManagedIStreamDataReader </dd>
<dd>
<a class="el" href="group__DataLayerRaw.html#ga2278ef714f833c4f83b7d32d1e55b903" title="Creates an unmanaged DataReader that reads its byte stream from a file on disk.">NewUnmanagedFileDataReader</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga51f3f98a55aa9d27548e410362e891e3"></a><!-- doxytag: member="googleapis::client::NewUnmanagedIstreamDataReaderWithLength" ref="ga51f3f98a55aa9d27548e410362e891e3" args="(std::istream *stream, int64 length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DataReader* <a class="el" href="group__DataLayerRaw.html#ga51f3f98a55aa9d27548e410362e891e3">googleapis::client::NewUnmanagedIstreamDataReaderWithLength</a> </td>
          <td>(</td>
          <td class="paramtype">std::istream *&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates an unmanaged reader that reads its byte stream from a generic C++ std::istream of a known length. </p>
<p>This is similar to NewManagedIstreamDataReaderWithLength, but with a NULL deleter.</p>
<dl class="see"><dt><b>See also:</b></dt><dd>NewManagedIStreamDataReaderWIthLength </dd>
<dd>
<a class="el" href="group__DataLayerRaw.html#ga2278ef714f833c4f83b7d32d1e55b903" title="Creates an unmanaged DataReader that reads its byte stream from a file on disk.">NewUnmanagedFileDataReader</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div>
  <div id="nav-path" class="navpath">
    <ul>

    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.6.1 </li>
   </ul>
 </div>


</body>
</html>
